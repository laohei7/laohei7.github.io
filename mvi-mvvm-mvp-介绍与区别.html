<!DOCTYPE html SYSTEM "about:legacy-compat">
<html lang="en-US" data-preset="contrast" data-primary-color="#307FFF"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta charset="UTF-8"><meta name="robots" content="noindex"><meta name="built-on" content="2025-07-28T13:50:37.128226114"><title>MVI、MVVM、MVP 介绍与区别 | Laohei Blog</title><script type="application/json" id="virtual-toc-data">[{"id":"1-mvp-model-view-presenter","level":0,"title":"1️⃣ MVP（Model-View-Presenter）","anchor":"#1-mvp-model-view-presenter"},{"id":"2-mvvm-model-view-viewmodel","level":0,"title":"2️⃣ MVVM（Model-View-ViewModel）","anchor":"#2-mvvm-model-view-viewmodel"},{"id":"3-mvi-model-view-intent","level":0,"title":"3️⃣ MVI（Model-View-Intent）","anchor":"#3-mvi-model-view-intent"},{"id":"-yymmem_8","level":0,"title":"🔥 总结","anchor":"#-yymmem_8"}]</script><script type="application/json" id="topic-shortcuts"></script><link href="https://resources.jetbrains.com/writerside/apidoc/6.10.0-b518/app.css" rel="stylesheet"><link rel="icon" type="image/png" sizes="16x16" href="images/my-logo.png"><meta name="image" content=""><!-- Open Graph --><meta property="og:title" content="MVI、MVVM、MVP 介绍与区别 | Laohei Blog"><meta property="og:description" content=""><meta property="og:image" content=""><meta property="og:site_name" content="Laohei Blog Help"><meta property="og:type" content="website"><meta property="og:locale" content="en_US"><meta property="og:url" content="writerside-documentation/mvi-mvvm-mvp-介绍与区别.html"><!-- End Open Graph --><!-- Twitter Card --><meta name="twitter:card" content="summary_large_image"><meta name="twitter:site" content=""><meta name="twitter:title" content="MVI、MVVM、MVP 介绍与区别 | Laohei Blog"><meta name="twitter:description" content=""><meta name="twitter:creator" content=""><meta name="twitter:image:src" content=""><!-- End Twitter Card --><!-- Schema.org WebPage --><script type="application/ld+json">{
    "@context": "http://schema.org",
    "@type": "WebPage",
    "@id": "writerside-documentation/mvi-mvvm-mvp-介绍与区别.html#webpage",
    "url": "writerside-documentation/mvi-mvvm-mvp-介绍与区别.html",
    "name": "MVI、MVVM、MVP 介绍与区别 | Laohei Blog",
    "description": "",
    "image": "",
    "inLanguage":"en-US"
}</script><!-- End Schema.org --><!-- Schema.org WebSite --><script type="application/ld+json">{
    "@type": "WebSite",
    "@id": "writerside-documentation/#website",
    "url": "writerside-documentation/",
    "name": "Laohei Blog Help"
}</script><!-- End Schema.org --></head><body data-id="MVI、MVVM、MVP-介绍与区别" data-main-title="MVI、MVVM、MVP 介绍与区别" data-article-props="{&quot;seeAlsoStyle&quot;:&quot;links&quot;}" data-template="article" data-breadcrumbs="博客"><div class="wrapper"><main class="panel _main"><header class="panel__header"><div class="container"><h3>Laohei Blog  Help</h3><div class="panel-trigger"></div></div></header><section class="panel__content"><div class="container"><article class="article" data-shortcut-switcher="inactive"><h1 data-toc="MVI、MVVM、MVP-介绍与区别" id="MVI、MVVM、MVP-介绍与区别.md">MVI、MVVM、MVP 介绍与区别</h1><p id="-yymmem_3">在 Android 开发中， <code class="code" id="-yymmem_9">MVI</code>、 <code class="code" id="-yymmem_10">MVVM</code>、 <code class="code" id="-yymmem_11">MVP</code> 是三种常见的架构模式。它们主要用于 <span class="control" id="-yymmem_12">分离 UI 和业务逻辑</span> ，提高代码的 <span class="control" id="-yymmem_13">可维护性</span> 和 <span class="control" id="-yymmem_14">可测试性</span>。</p><section class="chapter"><h2 id="1-mvp-model-view-presenter" data-toc="1-mvp-model-view-presenter"><span class="control" id="-yymmem_20">1️⃣ MVP（Model-View-Presenter）</span></h2><section class="chapter"><h3 id="-yymmem_16" data-toc="-yymmem_16"><span class="control" id="-yymmem_26">📌 介绍</span></h3><p id="-yymmem_22">MVP 是一种较早的架构模式，主要将 <code class="code" id="-yymmem_27">View</code> 和 <code class="code" id="-yymmem_28">Model</code> 解耦，并通过 <code class="code" id="-yymmem_29">Presenter</code> 作为中间层。</p><ul class="list _bullet" id="-yymmem_23"><li class="list__item" id="-yymmem_30"><p><code class="code" id="-yymmem_33">View</code> （界面层）：Activity / Fragment，负责 UI 交互。</p></li><li class="list__item" id="-yymmem_31"><p><code class="code" id="-yymmem_34">Presenter</code> （业务逻辑层）：处理业务逻辑，并通知 <code class="code" id="-yymmem_35">View</code> 更新 UI。</p></li><li class="list__item" id="-yymmem_32"><p><code class="code" id="-yymmem_36">Model</code> （数据层）：负责数据操作，例如数据库、网络请求等。</p></li></ul><p id="-yymmem_24">📌 <span class="control" id="-yymmem_37">核心思想</span>： <code class="code" id="-yymmem_38">View</code> 只负责 UI 展示， <code class="code" id="-yymmem_39">Presenter</code> 负责逻辑处理， <code class="code" id="-yymmem_40">Model</code> 提供数据。</p></section><section class="chapter"><h3 id="-yymmem_17" data-toc="-yymmem_17"><span class="control" id="-yymmem_46">📝 示例</span></h3><section class="chapter"><h4 id="1-model" data-toc="1-model"><span class="control" id="-yymmem_49">1️⃣ 创建 Model（数据层）</span></h4><div class="code-block" data-lang="kotlin">
interface LoginModel {
    fun login(username: String, password: String, callback: (Boolean) -&gt; Unit)
}

class LoginModelImpl : LoginModel {
    override fun login(username: String, password: String, callback: (Boolean) -&gt; Unit) {
        callback(username == &quot;admin&quot; &amp;&amp; password == &quot;1234&quot;) // 简单模拟
    }
}
</div></section><section class="chapter"><h4 id="2-view-ui" data-toc="2-view-ui"><span class="control" id="-yymmem_52">2️⃣ 创建 View（UI 层接口）</span></h4><div class="code-block" data-lang="kotlin">
interface LoginView {
    fun showLoading()
    fun hideLoading()
    fun showLoginSuccess()
    fun showLoginError()
}
</div></section><section class="chapter"><h4 id="3-presenter" data-toc="3-presenter"><span class="control" id="-yymmem_55">3️⃣ 创建 Presenter（业务逻辑层）</span></h4><div class="code-block" data-lang="kotlin">
class LoginPresenter(private val view: LoginView, private val model: LoginModel) {
    fun onLoginClicked(username: String, password: String) {
        view.showLoading()
        model.login(username, password) { isSuccess -&gt;
            view.hideLoading()
            if (isSuccess) view.showLoginSuccess() else view.showLoginError()
        }
    }
}
</div></section><section class="chapter"><h4 id="4-activity-loginview" data-toc="4-activity-loginview"><span class="control" id="-yymmem_58">4️⃣ 在 Activity 中实现 LoginView</span></h4><div class="code-block" data-lang="kotlin">
class LoginActivity : AppCompatActivity(), LoginView {
    private lateinit var presenter: LoginPresenter

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_login)
        presenter = LoginPresenter(this, LoginModelImpl())

        findViewById&lt;Button&gt;(R.id.login_button).setOnClickListener {
            presenter.onLoginClicked(&quot;admin&quot;, &quot;1234&quot;)
        }
    }

    override fun showLoading() { /* 显示加载动画 */ }
    override fun hideLoading() { /* 隐藏加载动画 */ }
    override fun showLoginSuccess() { Toast.makeText(this, &quot;登录成功&quot;, Toast.LENGTH_SHORT).show() }
    override fun showLoginError() { Toast.makeText(this, &quot;登录失败&quot;, Toast.LENGTH_SHORT).show() }
}
</div></section></section><section class="chapter"><h3 id="-yymmem_18" data-toc="-yymmem_18"><span class="control" id="-yymmem_61">✅ 优势</span></h3><p id="-yymmem_60">✔ <span class="control" id="-yymmem_62">解耦 UI 和逻辑</span>， <code class="code" id="-yymmem_63">View</code> 只负责 UI， <code class="code" id="-yymmem_64">Presenter</code> 处理业务逻辑。 <br> ✔ <code class="code" id="-yymmem_66">Presenter</code> <span class="control" id="-yymmem_67">可单独测试</span> ，提高可测试性。</p></section><section class="chapter"><h3 id="-yymmem_19" data-toc="-yymmem_19"><span class="control" id="-yymmem_71">❌ 缺点</span></h3><p id="-yymmem_69">❌ <span class="control" id="-yymmem_72">Presenter 可能变得很大</span> ，随着功能增加，可能导致 <code class="code" id="-yymmem_73">Presenter</code> 代码臃肿。</p></section></section><section class="chapter"><h2 id="2-mvvm-model-view-viewmodel" data-toc="2-mvvm-model-view-viewmodel"><span class="control" id="-yymmem_79">2️⃣ MVVM（Model-View-ViewModel）</span></h2><section class="chapter"><h3 id="-yymmem_75" data-toc="-yymmem_75"><span class="control" id="-yymmem_85">📌 介绍</span></h3><p id="-yymmem_81">MVVM 由 Google 官方推荐，借助 <code class="code" id="-yymmem_86">LiveData</code> 或 <code class="code" id="-yymmem_87">StateFlow</code> 进行数据绑定，使 <code class="code" id="-yymmem_88">ViewModel</code> 持有数据并驱动 UI。</p><ul class="list _bullet" id="-yymmem_82"><li class="list__item" id="-yymmem_89"><p><code class="code" id="-yymmem_92">Model</code> （数据层）：负责数据操作。</p></li><li class="list__item" id="-yymmem_90"><p><code class="code" id="-yymmem_93">ViewModel</code> （逻辑层）：负责数据处理，使用 <code class="code" id="-yymmem_94">LiveData</code>/<code class="code" id="-yymmem_95">StateFlow</code> 让 <code class="code" id="-yymmem_96">View</code> 观察数据变化。</p></li><li class="list__item" id="-yymmem_91"><p><code class="code" id="-yymmem_97">View</code> （界面层）：Activity / Fragment，观察 <code class="code" id="-yymmem_98">ViewModel</code> 并更新 UI。</p></li></ul><p id="-yymmem_83">📌 <span class="control" id="-yymmem_99">核心思想</span>： <code class="code" id="-yymmem_100">View</code> 监听 <code class="code" id="-yymmem_101">ViewModel</code> 的数据变化，数据驱动 UI。</p></section><section class="chapter"><h3 id="-yymmem_76" data-toc="-yymmem_76"><span class="control" id="-yymmem_105">📝 示例</span></h3><section class="chapter"><h4 id="1-viewmodel" data-toc="1-viewmodel"><span class="control" id="-yymmem_108">1️⃣ 创建 ViewModel</span></h4><div class="code-block" data-lang="kotlin">
class LoginViewModel : ViewModel() {
    private val _loginResult = MutableLiveData&lt;Boolean&gt;()
    val loginResult: LiveData&lt;Boolean&gt; get() = _loginResult

    fun login(username: String, password: String) {
        _loginResult.value = (username == &quot;admin&quot; &amp;&amp; password == &quot;1234&quot;) // 模拟登录
    }
}
</div></section><section class="chapter"><h4 id="2-activity-viewmodel" data-toc="2-activity-viewmodel"><span class="control" id="-yymmem_111">2️⃣ 在 Activity 中观察 ViewModel</span></h4><div class="code-block" data-lang="kotlin">
class LoginActivity : AppCompatActivity() {
    private lateinit var viewModel: LoginViewModel

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_login)

        viewModel = ViewModelProvider(this)[LoginViewModel::class.java]

        findViewById&lt;Button&gt;(R.id.login_button).setOnClickListener {
            viewModel.login(&quot;admin&quot;, &quot;1234&quot;)
        }

        viewModel.loginResult.observe(this) { isSuccess -&gt;
            if (isSuccess) Toast.makeText(this, &quot;登录成功&quot;, Toast.LENGTH_SHORT).show()
            else Toast.makeText(this, &quot;登录失败&quot;, Toast.LENGTH_SHORT).show()
        }
    }
}
</div></section></section><section class="chapter"><h3 id="-yymmem_77" data-toc="-yymmem_77"><span class="control" id="-yymmem_114">✅ 优势</span></h3><p id="-yymmem_113">✔ <span class="control" id="-yymmem_115">ViewModel 生命周期安全</span> ，不会因 Activity 旋转而丢失数据。 <br> ✔ <code class="code" id="-yymmem_117">View</code> 只监听数据变化， <span class="control" id="-yymmem_118">减少 UI 层代码</span>。 <br> ✔ <span class="control" id="-yymmem_120">数据驱动 UI</span> ，逻辑更清晰。</p></section><section class="chapter"><h3 id="-yymmem_78" data-toc="-yymmem_78"><span class="control" id="-yymmem_124">❌ 缺点</span></h3><p id="-yymmem_122">❌ <span class="control" id="-yymmem_125">LiveData 可能导致内存泄漏</span> （如果没有正确清理）。 <br> ❌ <span class="control" id="-yymmem_127">数据流动较隐式</span> ，初学者可能不容易理解。</p></section></section><section class="chapter"><h2 id="3-mvi-model-view-intent" data-toc="3-mvi-model-view-intent"><span class="control" id="-yymmem_133">3️⃣ MVI（Model-View-Intent）</span></h2><section class="chapter"><h3 id="-yymmem_129" data-toc="-yymmem_129"><span class="control" id="-yymmem_139">📌 介绍</span></h3><p id="-yymmem_135">MVI 采用 <span class="control" id="-yymmem_140">单向数据流</span>， <code class="code" id="-yymmem_141">View</code> 触发 <code class="code" id="-yymmem_142">Intent</code> （用户意图）， <code class="code" id="-yymmem_143">ViewModel</code> 处理后更新 <code class="code" id="-yymmem_144">State</code> （状态），然后 <code class="code" id="-yymmem_145">View</code> 监听 <code class="code" id="-yymmem_146">State</code> 变化。</p><ul class="list _bullet" id="-yymmem_136"><li class="list__item" id="-yymmem_147"><p><code class="code" id="-yymmem_151">Model</code> （数据层）：提供数据。</p></li><li class="list__item" id="-yymmem_148"><p><code class="code" id="-yymmem_152">View</code> （界面层）：监听 <code class="code" id="-yymmem_153">State</code> 并更新 UI。</p></li><li class="list__item" id="-yymmem_149"><p><code class="code" id="-yymmem_154">Intent</code> （用户意图）：用户的操作，如点击按钮。</p></li><li class="list__item" id="-yymmem_150"><p><code class="code" id="-yymmem_155">State</code> （状态）：ViewModel 维护的 UI 状态， <code class="code" id="-yymmem_156">View</code> 观察它。</p></li></ul><p id="-yymmem_137">📌 <span class="control" id="-yymmem_157">核心思想</span> ：UI 由 <code class="code" id="-yymmem_158">State</code> 驱动，所有事件是单向的，确保数据一致性。</p></section><section class="chapter"><h3 id="-yymmem_130" data-toc="-yymmem_130"><span class="control" id="-yymmem_163">📝 示例</span></h3><section class="chapter"><h4 id="1-ui" data-toc="1-ui"><span class="control" id="-yymmem_166">1️⃣ 定义 UI 状态</span></h4><div class="code-block" data-lang="kotlin">
data class LoginState(val isLoading: Boolean = false, val isSuccess: Boolean? = null)
</div></section><section class="chapter"><h4 id="2-viewmodel" data-toc="2-viewmodel"><span class="control" id="-yymmem_169">2️⃣ 创建 ViewModel</span></h4><div class="code-block" data-lang="kotlin">
class LoginViewModel : ViewModel() {
    private val _state = MutableStateFlow(LoginState())
    val state: StateFlow&lt;LoginState&gt; get() = _state

    fun login(username: String, password: String) {
        _state.value = LoginState(isLoading = true)
        viewModelScope.launch {
            delay(1000) // 模拟网络请求
            _state.value = LoginState(isSuccess = (username == &quot;admin&quot; &amp;&amp; password == &quot;1234&quot;))
        }
    }
}
</div></section><section class="chapter"><h4 id="3-activity" data-toc="3-activity"><span class="control" id="-yymmem_172">3️⃣ 在 Activity 中监听状态</span></h4><div class="code-block" data-lang="kotlin">
class LoginActivity : AppCompatActivity() {
    private lateinit var viewModel: LoginViewModel

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_login)

        viewModel = ViewModelProvider(this)[LoginViewModel::class.java]

        lifecycleScope.launch {
            viewModel.state.collect { state -&gt;
                if (state.isLoading) showLoading()
                else if (state.isSuccess == true) showSuccess()
                else showError()
            }
        }
    }
}
</div></section></section><section class="chapter"><h3 id="-yymmem_131" data-toc="-yymmem_131"><span class="control" id="-yymmem_175">✅ 优势</span></h3><p id="-yymmem_174">✔ <span class="control" id="-yymmem_176">状态管理清晰</span> ，避免数据不一致。 <br> ✔ <span class="control" id="-yymmem_178">单向数据流</span> ，逻辑更易维护。</p></section><section class="chapter"><h3 id="-yymmem_132" data-toc="-yymmem_132"><span class="control" id="-yymmem_182">❌ 缺点</span></h3><p id="-yymmem_180">❌ <span class="control" id="-yymmem_183">需要理解 StateFlow / Redux 思想</span> ，初学者不易上手。</p></section></section><section class="chapter"><h2 id="-yymmem_8" data-toc="-yymmem_8"><span class="control" id="-yymmem_187">🔥 总结</span></h2><div class="table-wrapper"><table class="wide" id="-yymmem_185"><thead><tr class="ijRowHead" id="-yymmem_188"><th id="-yymmem_192"><p>架构</p></th><th id="-yymmem_193"><p>适用场景</p></th><th id="-yymmem_194"><p>优势</p></th><th id="-yymmem_195"><p>缺点</p></th></tr></thead><tbody><tr id="-yymmem_189"><td id="-yymmem_196"><p>MVP</p></td><td id="-yymmem_197"><p>小型项目</p></td><td id="-yymmem_198"><p>解耦 UI 和逻辑</p></td><td id="-yymmem_199"><p>Presenter 可能变大</p></td></tr><tr id="-yymmem_190"><td id="-yymmem_200"><p>MVVM</p></td><td id="-yymmem_201"><p>官方推荐</p></td><td id="-yymmem_202"><p>数据驱动 UI</p></td><td id="-yymmem_203"><p>可能导致内存泄漏</p></td></tr><tr id="-yymmem_191"><td id="-yymmem_204"><p>MVI</p></td><td id="-yymmem_205"><p>状态驱动</p></td><td id="-yymmem_206"><p>单向数据流，数据一致性好</p></td><td id="-yymmem_207"><p>学习曲线较陡</p></td></tr></tbody></table></div><p id="-yymmem_186">如果是 <span class="control" id="-yymmem_208">现代 Android</span> 开发， <span class="control" id="-yymmem_209">推荐 MVVM / MVI</span> 🚀。</p></section><div class="last-modified">Last modified: 07 May 2025</div><div data-feedback-placeholder="true"></div><div class="navigation-links _bottom"><a href="kotlin中object类线程安全.html" class="navigation-links__prev">Kotlin中Object类线程安全</a></div></article><div id="disqus_thread"></div></div></section></main></div><script src="https://resources.jetbrains.com/writerside/apidoc/6.10.0-b518/app.js"></script></body></html>