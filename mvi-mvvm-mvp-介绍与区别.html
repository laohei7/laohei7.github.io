<!DOCTYPE html SYSTEM "about:legacy-compat">
<html lang="en-US" data-preset="contrast" data-primary-color="#307FFF"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta charset="UTF-8"><meta name="robots" content="noindex"><meta name="built-on" content="2025-08-29T01:09:57.036449169"><!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-LR6H6HWQQY"></script>
<script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'G-LR6H6HWQQY');
</script><title>MVI、MVVM、MVP 介绍与区别 | Laohei Blog</title><script type="application/json" id="virtual-toc-data">[{"id":"1-mvp-model-view-presenter","level":0,"title":"1️⃣ MVP（Model-View-Presenter）","anchor":"#1-mvp-model-view-presenter"},{"id":"2-mvvm-model-view-viewmodel","level":0,"title":"2️⃣ MVVM（Model-View-ViewModel）","anchor":"#2-mvvm-model-view-viewmodel"},{"id":"3-mvi-model-view-intent","level":0,"title":"3️⃣ MVI（Model-View-Intent）","anchor":"#3-mvi-model-view-intent"},{"id":"c1x3te_8","level":0,"title":"🔥 总结","anchor":"#c1x3te_8"}]</script><script type="application/json" id="topic-shortcuts"></script><link href="https://resources.jetbrains.com/writerside/apidoc/6.10.0-b518/app.css" rel="stylesheet"><link rel="icon" type="image/png" sizes="16x16" href="images/my-logo.png"><meta name="image" content=""><!-- Open Graph --><meta property="og:title" content="MVI、MVVM、MVP 介绍与区别 | Laohei Blog"><meta property="og:description" content=""><meta property="og:image" content=""><meta property="og:site_name" content="Laohei Blog Help"><meta property="og:type" content="website"><meta property="og:locale" content="en_US"><meta property="og:url" content="writerside-documentation/mvi-mvvm-mvp-介绍与区别.html"><!-- End Open Graph --><!-- Twitter Card --><meta name="twitter:card" content="summary_large_image"><meta name="twitter:site" content=""><meta name="twitter:title" content="MVI、MVVM、MVP 介绍与区别 | Laohei Blog"><meta name="twitter:description" content=""><meta name="twitter:creator" content=""><meta name="twitter:image:src" content=""><!-- End Twitter Card --><!-- Schema.org WebPage --><script type="application/ld+json">{
    "@context": "http://schema.org",
    "@type": "WebPage",
    "@id": "writerside-documentation/mvi-mvvm-mvp-介绍与区别.html#webpage",
    "url": "writerside-documentation/mvi-mvvm-mvp-介绍与区别.html",
    "name": "MVI、MVVM、MVP 介绍与区别 | Laohei Blog",
    "description": "",
    "image": "",
    "inLanguage":"en-US"
}</script><!-- End Schema.org --><!-- Schema.org WebSite --><script type="application/ld+json">{
    "@type": "WebSite",
    "@id": "writerside-documentation/#website",
    "url": "writerside-documentation/",
    "name": "Laohei Blog Help"
}</script><!-- End Schema.org --></head><body data-id="MVI、MVVM、MVP-介绍与区别" data-main-title="MVI、MVVM、MVP 介绍与区别" data-article-props="{&quot;seeAlsoStyle&quot;:&quot;links&quot;}" data-template="article" data-breadcrumbs="博客"><div class="wrapper"><main class="panel _main"><header class="panel__header"><div class="container"><h3>Laohei Blog  Help</h3><div class="panel-trigger"></div></div></header><section class="panel__content"><div class="container"><article class="article" data-shortcut-switcher="inactive"><h1 data-toc="MVI、MVVM、MVP-介绍与区别" id="MVI、MVVM、MVP-介绍与区别.md">MVI、MVVM、MVP 介绍与区别</h1><p id="c1x3te_3">在 Android 开发中， <code class="code" id="c1x3te_9">MVI</code>、 <code class="code" id="c1x3te_10">MVVM</code>、 <code class="code" id="c1x3te_11">MVP</code> 是三种常见的架构模式。它们主要用于 <span class="control" id="c1x3te_12">分离 UI 和业务逻辑</span> ，提高代码的 <span class="control" id="c1x3te_13">可维护性</span> 和 <span class="control" id="c1x3te_14">可测试性</span>。</p><section class="chapter"><h2 id="1-mvp-model-view-presenter" data-toc="1-mvp-model-view-presenter"><span class="control" id="c1x3te_20">1️⃣ MVP（Model-View-Presenter）</span></h2><section class="chapter"><h3 id="c1x3te_16" data-toc="c1x3te_16"><span class="control" id="c1x3te_26">📌 介绍</span></h3><p id="c1x3te_22">MVP 是一种较早的架构模式，主要将 <code class="code" id="c1x3te_27">View</code> 和 <code class="code" id="c1x3te_28">Model</code> 解耦，并通过 <code class="code" id="c1x3te_29">Presenter</code> 作为中间层。</p><ul class="list _bullet" id="c1x3te_23"><li class="list__item" id="c1x3te_30"><p><code class="code" id="c1x3te_33">View</code> （界面层）：Activity / Fragment，负责 UI 交互。</p></li><li class="list__item" id="c1x3te_31"><p><code class="code" id="c1x3te_34">Presenter</code> （业务逻辑层）：处理业务逻辑，并通知 <code class="code" id="c1x3te_35">View</code> 更新 UI。</p></li><li class="list__item" id="c1x3te_32"><p><code class="code" id="c1x3te_36">Model</code> （数据层）：负责数据操作，例如数据库、网络请求等。</p></li></ul><p id="c1x3te_24">📌 <span class="control" id="c1x3te_37">核心思想</span>： <code class="code" id="c1x3te_38">View</code> 只负责 UI 展示， <code class="code" id="c1x3te_39">Presenter</code> 负责逻辑处理， <code class="code" id="c1x3te_40">Model</code> 提供数据。</p></section><section class="chapter"><h3 id="c1x3te_17" data-toc="c1x3te_17"><span class="control" id="c1x3te_46">📝 示例</span></h3><section class="chapter"><h4 id="1-model" data-toc="1-model"><span class="control" id="c1x3te_49">1️⃣ 创建 Model（数据层）</span></h4><div class="code-block" data-lang="kotlin">
interface LoginModel {
    fun login(username: String, password: String, callback: (Boolean) -&gt; Unit)
}

class LoginModelImpl : LoginModel {
    override fun login(username: String, password: String, callback: (Boolean) -&gt; Unit) {
        callback(username == &quot;admin&quot; &amp;&amp; password == &quot;1234&quot;) // 简单模拟
    }
}
</div></section><section class="chapter"><h4 id="2-view-ui" data-toc="2-view-ui"><span class="control" id="c1x3te_52">2️⃣ 创建 View（UI 层接口）</span></h4><div class="code-block" data-lang="kotlin">
interface LoginView {
    fun showLoading()
    fun hideLoading()
    fun showLoginSuccess()
    fun showLoginError()
}
</div></section><section class="chapter"><h4 id="3-presenter" data-toc="3-presenter"><span class="control" id="c1x3te_55">3️⃣ 创建 Presenter（业务逻辑层）</span></h4><div class="code-block" data-lang="kotlin">
class LoginPresenter(private val view: LoginView, private val model: LoginModel) {
    fun onLoginClicked(username: String, password: String) {
        view.showLoading()
        model.login(username, password) { isSuccess -&gt;
            view.hideLoading()
            if (isSuccess) view.showLoginSuccess() else view.showLoginError()
        }
    }
}
</div></section><section class="chapter"><h4 id="4-activity-loginview" data-toc="4-activity-loginview"><span class="control" id="c1x3te_58">4️⃣ 在 Activity 中实现 LoginView</span></h4><div class="code-block" data-lang="kotlin">
class LoginActivity : AppCompatActivity(), LoginView {
    private lateinit var presenter: LoginPresenter

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_login)
        presenter = LoginPresenter(this, LoginModelImpl())

        findViewById&lt;Button&gt;(R.id.login_button).setOnClickListener {
            presenter.onLoginClicked(&quot;admin&quot;, &quot;1234&quot;)
        }
    }

    override fun showLoading() { /* 显示加载动画 */ }
    override fun hideLoading() { /* 隐藏加载动画 */ }
    override fun showLoginSuccess() { Toast.makeText(this, &quot;登录成功&quot;, Toast.LENGTH_SHORT).show() }
    override fun showLoginError() { Toast.makeText(this, &quot;登录失败&quot;, Toast.LENGTH_SHORT).show() }
}
</div></section></section><section class="chapter"><h3 id="c1x3te_18" data-toc="c1x3te_18"><span class="control" id="c1x3te_61">✅ 优势</span></h3><p id="c1x3te_60">✔ <span class="control" id="c1x3te_62">解耦 UI 和逻辑</span>， <code class="code" id="c1x3te_63">View</code> 只负责 UI， <code class="code" id="c1x3te_64">Presenter</code> 处理业务逻辑。 <br> ✔ <code class="code" id="c1x3te_66">Presenter</code> <span class="control" id="c1x3te_67">可单独测试</span> ，提高可测试性。</p></section><section class="chapter"><h3 id="c1x3te_19" data-toc="c1x3te_19"><span class="control" id="c1x3te_71">❌ 缺点</span></h3><p id="c1x3te_69">❌ <span class="control" id="c1x3te_72">Presenter 可能变得很大</span> ，随着功能增加，可能导致 <code class="code" id="c1x3te_73">Presenter</code> 代码臃肿。</p></section></section><section class="chapter"><h2 id="2-mvvm-model-view-viewmodel" data-toc="2-mvvm-model-view-viewmodel"><span class="control" id="c1x3te_79">2️⃣ MVVM（Model-View-ViewModel）</span></h2><section class="chapter"><h3 id="c1x3te_75" data-toc="c1x3te_75"><span class="control" id="c1x3te_85">📌 介绍</span></h3><p id="c1x3te_81">MVVM 由 Google 官方推荐，借助 <code class="code" id="c1x3te_86">LiveData</code> 或 <code class="code" id="c1x3te_87">StateFlow</code> 进行数据绑定，使 <code class="code" id="c1x3te_88">ViewModel</code> 持有数据并驱动 UI。</p><ul class="list _bullet" id="c1x3te_82"><li class="list__item" id="c1x3te_89"><p><code class="code" id="c1x3te_92">Model</code> （数据层）：负责数据操作。</p></li><li class="list__item" id="c1x3te_90"><p><code class="code" id="c1x3te_93">ViewModel</code> （逻辑层）：负责数据处理，使用 <code class="code" id="c1x3te_94">LiveData</code>/<code class="code" id="c1x3te_95">StateFlow</code> 让 <code class="code" id="c1x3te_96">View</code> 观察数据变化。</p></li><li class="list__item" id="c1x3te_91"><p><code class="code" id="c1x3te_97">View</code> （界面层）：Activity / Fragment，观察 <code class="code" id="c1x3te_98">ViewModel</code> 并更新 UI。</p></li></ul><p id="c1x3te_83">📌 <span class="control" id="c1x3te_99">核心思想</span>： <code class="code" id="c1x3te_100">View</code> 监听 <code class="code" id="c1x3te_101">ViewModel</code> 的数据变化，数据驱动 UI。</p></section><section class="chapter"><h3 id="c1x3te_76" data-toc="c1x3te_76"><span class="control" id="c1x3te_105">📝 示例</span></h3><section class="chapter"><h4 id="1-viewmodel" data-toc="1-viewmodel"><span class="control" id="c1x3te_108">1️⃣ 创建 ViewModel</span></h4><div class="code-block" data-lang="kotlin">
class LoginViewModel : ViewModel() {
    private val _loginResult = MutableLiveData&lt;Boolean&gt;()
    val loginResult: LiveData&lt;Boolean&gt; get() = _loginResult

    fun login(username: String, password: String) {
        _loginResult.value = (username == &quot;admin&quot; &amp;&amp; password == &quot;1234&quot;) // 模拟登录
    }
}
</div></section><section class="chapter"><h4 id="2-activity-viewmodel" data-toc="2-activity-viewmodel"><span class="control" id="c1x3te_111">2️⃣ 在 Activity 中观察 ViewModel</span></h4><div class="code-block" data-lang="kotlin">
class LoginActivity : AppCompatActivity() {
    private lateinit var viewModel: LoginViewModel

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_login)

        viewModel = ViewModelProvider(this)[LoginViewModel::class.java]

        findViewById&lt;Button&gt;(R.id.login_button).setOnClickListener {
            viewModel.login(&quot;admin&quot;, &quot;1234&quot;)
        }

        viewModel.loginResult.observe(this) { isSuccess -&gt;
            if (isSuccess) Toast.makeText(this, &quot;登录成功&quot;, Toast.LENGTH_SHORT).show()
            else Toast.makeText(this, &quot;登录失败&quot;, Toast.LENGTH_SHORT).show()
        }
    }
}
</div></section></section><section class="chapter"><h3 id="c1x3te_77" data-toc="c1x3te_77"><span class="control" id="c1x3te_114">✅ 优势</span></h3><p id="c1x3te_113">✔ <span class="control" id="c1x3te_115">ViewModel 生命周期安全</span> ，不会因 Activity 旋转而丢失数据。 <br> ✔ <code class="code" id="c1x3te_117">View</code> 只监听数据变化， <span class="control" id="c1x3te_118">减少 UI 层代码</span>。 <br> ✔ <span class="control" id="c1x3te_120">数据驱动 UI</span> ，逻辑更清晰。</p></section><section class="chapter"><h3 id="c1x3te_78" data-toc="c1x3te_78"><span class="control" id="c1x3te_124">❌ 缺点</span></h3><p id="c1x3te_122">❌ <span class="control" id="c1x3te_125">LiveData 可能导致内存泄漏</span> （如果没有正确清理）。 <br> ❌ <span class="control" id="c1x3te_127">数据流动较隐式</span> ，初学者可能不容易理解。</p></section></section><section class="chapter"><h2 id="3-mvi-model-view-intent" data-toc="3-mvi-model-view-intent"><span class="control" id="c1x3te_133">3️⃣ MVI（Model-View-Intent）</span></h2><section class="chapter"><h3 id="c1x3te_129" data-toc="c1x3te_129"><span class="control" id="c1x3te_139">📌 介绍</span></h3><p id="c1x3te_135">MVI 采用 <span class="control" id="c1x3te_140">单向数据流</span>， <code class="code" id="c1x3te_141">View</code> 触发 <code class="code" id="c1x3te_142">Intent</code> （用户意图）， <code class="code" id="c1x3te_143">ViewModel</code> 处理后更新 <code class="code" id="c1x3te_144">State</code> （状态），然后 <code class="code" id="c1x3te_145">View</code> 监听 <code class="code" id="c1x3te_146">State</code> 变化。</p><ul class="list _bullet" id="c1x3te_136"><li class="list__item" id="c1x3te_147"><p><code class="code" id="c1x3te_151">Model</code> （数据层）：提供数据。</p></li><li class="list__item" id="c1x3te_148"><p><code class="code" id="c1x3te_152">View</code> （界面层）：监听 <code class="code" id="c1x3te_153">State</code> 并更新 UI。</p></li><li class="list__item" id="c1x3te_149"><p><code class="code" id="c1x3te_154">Intent</code> （用户意图）：用户的操作，如点击按钮。</p></li><li class="list__item" id="c1x3te_150"><p><code class="code" id="c1x3te_155">State</code> （状态）：ViewModel 维护的 UI 状态， <code class="code" id="c1x3te_156">View</code> 观察它。</p></li></ul><p id="c1x3te_137">📌 <span class="control" id="c1x3te_157">核心思想</span> ：UI 由 <code class="code" id="c1x3te_158">State</code> 驱动，所有事件是单向的，确保数据一致性。</p></section><section class="chapter"><h3 id="c1x3te_130" data-toc="c1x3te_130"><span class="control" id="c1x3te_163">📝 示例</span></h3><section class="chapter"><h4 id="1-ui" data-toc="1-ui"><span class="control" id="c1x3te_166">1️⃣ 定义 UI 状态</span></h4><div class="code-block" data-lang="kotlin">
data class LoginState(val isLoading: Boolean = false, val isSuccess: Boolean? = null)
</div></section><section class="chapter"><h4 id="2-viewmodel" data-toc="2-viewmodel"><span class="control" id="c1x3te_169">2️⃣ 创建 ViewModel</span></h4><div class="code-block" data-lang="kotlin">
class LoginViewModel : ViewModel() {
    private val _state = MutableStateFlow(LoginState())
    val state: StateFlow&lt;LoginState&gt; get() = _state

    fun login(username: String, password: String) {
        _state.value = LoginState(isLoading = true)
        viewModelScope.launch {
            delay(1000) // 模拟网络请求
            _state.value = LoginState(isSuccess = (username == &quot;admin&quot; &amp;&amp; password == &quot;1234&quot;))
        }
    }
}
</div></section><section class="chapter"><h4 id="3-activity" data-toc="3-activity"><span class="control" id="c1x3te_172">3️⃣ 在 Activity 中监听状态</span></h4><div class="code-block" data-lang="kotlin">
class LoginActivity : AppCompatActivity() {
    private lateinit var viewModel: LoginViewModel

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_login)

        viewModel = ViewModelProvider(this)[LoginViewModel::class.java]

        lifecycleScope.launch {
            viewModel.state.collect { state -&gt;
                if (state.isLoading) showLoading()
                else if (state.isSuccess == true) showSuccess()
                else showError()
            }
        }
    }
}
</div></section></section><section class="chapter"><h3 id="c1x3te_131" data-toc="c1x3te_131"><span class="control" id="c1x3te_175">✅ 优势</span></h3><p id="c1x3te_174">✔ <span class="control" id="c1x3te_176">状态管理清晰</span> ，避免数据不一致。 <br> ✔ <span class="control" id="c1x3te_178">单向数据流</span> ，逻辑更易维护。</p></section><section class="chapter"><h3 id="c1x3te_132" data-toc="c1x3te_132"><span class="control" id="c1x3te_182">❌ 缺点</span></h3><p id="c1x3te_180">❌ <span class="control" id="c1x3te_183">需要理解 StateFlow / Redux 思想</span> ，初学者不易上手。</p></section></section><section class="chapter"><h2 id="c1x3te_8" data-toc="c1x3te_8"><span class="control" id="c1x3te_187">🔥 总结</span></h2><div class="table-wrapper"><table class="wide" id="c1x3te_185"><thead><tr class="ijRowHead" id="c1x3te_188"><th id="c1x3te_192"><p>架构</p></th><th id="c1x3te_193"><p>适用场景</p></th><th id="c1x3te_194"><p>优势</p></th><th id="c1x3te_195"><p>缺点</p></th></tr></thead><tbody><tr id="c1x3te_189"><td id="c1x3te_196"><p>MVP</p></td><td id="c1x3te_197"><p>小型项目</p></td><td id="c1x3te_198"><p>解耦 UI 和逻辑</p></td><td id="c1x3te_199"><p>Presenter 可能变大</p></td></tr><tr id="c1x3te_190"><td id="c1x3te_200"><p>MVVM</p></td><td id="c1x3te_201"><p>官方推荐</p></td><td id="c1x3te_202"><p>数据驱动 UI</p></td><td id="c1x3te_203"><p>可能导致内存泄漏</p></td></tr><tr id="c1x3te_191"><td id="c1x3te_204"><p>MVI</p></td><td id="c1x3te_205"><p>状态驱动</p></td><td id="c1x3te_206"><p>单向数据流，数据一致性好</p></td><td id="c1x3te_207"><p>学习曲线较陡</p></td></tr></tbody></table></div><p id="c1x3te_186">如果是 <span class="control" id="c1x3te_208">现代 Android</span> 开发， <span class="control" id="c1x3te_209">推荐 MVVM / MVI</span> 🚀。</p></section><div class="last-modified">Last modified: 07 May 2025</div><div data-feedback-placeholder="true"></div><div class="navigation-links _bottom"><a href="kotlin中object类线程安全.html" class="navigation-links__prev">Kotlin中Object类线程安全</a></div></article><div id="disqus_thread"></div></div></section></main></div><script src="https://resources.jetbrains.com/writerside/apidoc/6.10.0-b518/app.js"></script></body></html>